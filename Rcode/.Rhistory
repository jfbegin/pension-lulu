priceArithAScall <- mean(DiscPayoffArithAScall)
priceArithASput <- mean(DiscPayoffArithASput)
priceGeoAPcall <- mean(DiscPayoffGeoAPcall)
priceGeoAPput <- mean(DiscPayoffGeoAPput)
priceGeoAScall <- mean(DiscPayoffGeoAScall)
priceGeoAsput <- mean(DiscPayoffGeoASput)
priceArithAPcall
priceArithAPput
priceArithAScall
priceArithASput
priceGeoAPcall
priceGeoAPput
priceGeoAScall
priceGeoAsput
#MoE = Margin of Error, based on 95% Confidence Interval
MoEArithAPcall <- 1.96 * sd(DiscPayoffArithAPcall) / sqrt(10000)
MoEArithAPput <- 1.96 * sd(DiscPayoffArithAPput) / sqrt(10000)
MoEArithAScall <- 1.96 * sd(DiscPayoffArithAScall) / sqrt(10000)
MoEArithASput <- 1.96 * sd(DiscPayoffArithASput) / sqrt(10000)
MoEGeoAPcall <- 1.96 * sd(DiscPayoffGeoAPcall) / sqrt(10000)
MoEGeoAPput <- 1.96 * sd(DiscPayoffGeoAPput) / sqrt(10000)
MoEGeoAScall <- 1.96 * sd(DiscPayoffGeoAScall) / sqrt(10000)
MoEGeoASput <- 1.96 * sd(DiscPayoffGeoASput) / sqrt(10000)
MoEArithAPcall
MoEArithAPput
MoEArithAScall
MoEArithASput
MoEGeoAPcall
MoEGeoAPput
MoEGeoAScall
MoEGeoASput
S_0 = 40
K = 40
sigma = 0.3
r = 0.08
del = 0.00
T = 1
N <- c(1, 2, 3, 5, 10, 50, 1000)
it<-5 #number of iterations
m <- T/it*(r-del-0.5*sigma^2) #mean
v <- sigma*((T/it)^0.5) #standard deviation
### Step 1.2 Create random variables ###
z<-rnorm(it) #random numbers drawn
x<-exp(m+v*z) #increment = S_t/S_(t-1)
s<-S_0*cumprod(x) #The samples, S_t's
### Step 1.3 Loop and calculate the averages ###
i<-1 #dummy for iteration
j<-1 #dummy for different N's
A<-c(0, 0, 0, 0, 0, 0, 0) #arithmetic averages (of 7 N's), initialize to 0
G<-c(1, 1, 1, 1, 1, 1, 1) #geometric averages, initialize to 1
for (j in 1:7){
while (i<=it){
if(i %% (it/N[j])==0) A[j]<-A[j]+s[i]
if(i %% (it/N[j])==0) G[j]<-G[j]*s[i]
i<-i+1
}
i<-1 #re-initialize for the next iteration
A[j]<-A[j]/N[j]
G[j]<-(G[j])^(1/N[j])
}
#Manually adjust for N=3 since 3 is not a factor of 10000
A[3] <- (s[round(it/3)] + s[round(it*2/3)] + s[round(it)])/3
G[3] <- (s[round(it/3)] * s[round(it*2/3)] * s[round(it)])^(1/3)
### Step 1.4 Create the answer table matrix and compute the Monte Carlo Values ###
MatrixTable<-array("", dim=c(3,10,5))
#1st parameter: 1=Arith., 2=Geo., 3=Analytical Values for Geo. in Q2
#2nd parameter: number of rows (last row = margin of error at 95% CI)
#3rd parameter: number of columns
i<-1 #dummy for row
j<-1 #dummy for column
k<-1 #dummy for table
for (k in 1:3){
MatrixTable[k, 1, 2] = "Average Price ($)"
MatrixTable[k, 1, 4] = "Average Strike ($)"
MatrixTable[k, 2, 1] = "N"
MatrixTable[k, 2, 2] = "Call"
MatrixTable[k, 2, 3] = "Put"
MatrixTable[k, 2, 4] = "Call"
MatrixTable[k, 2, 5] = "Put"
MatrixTable[k, 10, 1] = "Margin of Error at 95% CI"
}
for(i in 3:9){
MatrixTable[1, i, 1] = N[i-2]
MatrixTable[1, i, 2] = max(A[i-2] - K, 0)
MatrixTable[1, i, 3] = max(K - A[i-2], 0)
MatrixTable[1, i, 4] = max(s[it] - A[i-2] , 0)
MatrixTable[1, i, 5] = max(A[i-2] - s[it], 0)
MatrixTable[2, i, 1] = N[i-2]
MatrixTable[2, i, 2] = max(G[i-2] - K, 0)
MatrixTable[2, i, 3] = max(K - G[i-2], 0)
MatrixTable[2, i, 4] = max(s[it] - G[i-2], 0)
MatrixTable[2, i, 5] = max(G[i-2] - s[it], 0)
MatrixTable[3, i, 1] = N[i-2]
}
for(k in 1:2){
for (j in 2:5){
MatrixTable[k, 10, j] = (1.96/(7^0.5)
*sd(c(MatrixTable[k, 3, j], MatrixTable[k, 4, j],
MatrixTable[k, 5, j], MatrixTable[k, 6, j],
MatrixTable[k, 7, j], MatrixTable[k, 8, j],
MatrixTable[k, 9, j])))
}
}
### Step 1.5 Print the result ###
MatrixTable[1,,] #Arithmetic average
MatrixTable[2,,] #Geometric average
###### Q2 Analytical Values ######
### Step 1.1 Set Parameters ###
S_0 = 40
K = 40
sigma = 0.3
r = 0.08
del = 0.00
T = 1
N <- c(1, 2, 3, 5, 10, 50, 1000)
it<-10000 #number of iterations
m <- T/it*(r-del-0.5*sigma^2) #mean
v <- sigma*((T/it)^0.5) #standard deviation
### Step 1.2 Create random variables ###
z<-rnorm(it) #random numbers drawn
x<-exp(m+v*z) #increment = S_t/S_(t-1)
s<-S_0*cumprod(x) #The samples, S_t's
### Step 1.3 Loop and calculate the averages ###
i<-1 #dummy for iteration
j<-1 #dummy for different N's
A<-c(0, 0, 0, 0, 0, 0, 0) #arithmetic averages (of 7 N's), initialize to 0
G<-c(1, 1, 1, 1, 1, 1, 1) #geometric averages, initialize to 1
for (j in 1:7){
while (i<=it){
if(i %% (it/N[j])==0) A[j]<-A[j]+s[i]
if(i %% (it/N[j])==0) G[j]<-G[j]*s[i]
i<-i+1
}
i<-1 #re-initialize for the next iteration
A[j]<-A[j]/N[j]
G[j]<-(G[j])^(1/N[j])
}
#Manually adjust for N=3 since 3 is not a factor of 10000
A[3] <- (s[round(it/3)] + s[round(it*2/3)] + s[round(it)])/3
G[3] <- (s[round(it/3)] * s[round(it*2/3)] * s[round(it)])^(1/3)
### Step 1.4 Create the answer table matrix and compute the Monte Carlo Values ###
MatrixTable<-array("", dim=c(3,10,5))
#1st parameter: 1=Arith., 2=Geo., 3=Analytical Values for Geo. in Q2
#2nd parameter: number of rows (last row = margin of error at 95% CI)
#3rd parameter: number of columns
i<-1 #dummy for row
j<-1 #dummy for column
k<-1 #dummy for table
for (k in 1:3){
MatrixTable[k, 1, 2] = "Average Price ($)"
MatrixTable[k, 1, 4] = "Average Strike ($)"
MatrixTable[k, 2, 1] = "N"
MatrixTable[k, 2, 2] = "Call"
MatrixTable[k, 2, 3] = "Put"
MatrixTable[k, 2, 4] = "Call"
MatrixTable[k, 2, 5] = "Put"
MatrixTable[k, 10, 1] = "Margin of Error at 95% CI"
}
for(i in 3:9){
MatrixTable[1, i, 1] = N[i-2]
MatrixTable[1, i, 2] = max(A[i-2] - K, 0)
MatrixTable[1, i, 3] = max(K - A[i-2], 0)
MatrixTable[1, i, 4] = max(s[it] - A[i-2] , 0)
MatrixTable[1, i, 5] = max(A[i-2] - s[it], 0)
MatrixTable[2, i, 1] = N[i-2]
MatrixTable[2, i, 2] = max(G[i-2] - K, 0)
MatrixTable[2, i, 3] = max(K - G[i-2], 0)
MatrixTable[2, i, 4] = max(s[it] - G[i-2], 0)
MatrixTable[2, i, 5] = max(G[i-2] - s[it], 0)
MatrixTable[3, i, 1] = N[i-2]
}
for(k in 1:2){
for (j in 2:5){
MatrixTable[k, 10, j] = (1.96/(7^0.5)
*sd(c(MatrixTable[k, 3, j], MatrixTable[k, 4, j],
MatrixTable[k, 5, j], MatrixTable[k, 6, j],
MatrixTable[k, 7, j], MatrixTable[k, 8, j],
MatrixTable[k, 9, j])))
}
}
### Step 1.5 Print the result ###
MatrixTable[1,,] #Arithmetic average
MatrixTable[2,,] #Geometric average
z
###### Q2 Analytical Values ######
### Step 2.1 Parameter setting ###
del_asterisked <- 0.5*(r*(N-1)/N+(del+sigma^2/2)*(N+1)/N-sigma^2/N^2*(N+1)*(2*N+1)/6)
sigma_asterisked <- sigma/N * ((N+1)*(2*N+1)/6)^0.5
rho = 0.5 * (6*(N+1)/(2*N+1))^0.5
sigma_doubly_asterisked <- -2*rho*((N+1)*(2*N+1)/(6*N^2))^0.5
sigma_doubly_asterisked <- sigma*(1+(N+1)*(2*N+1)/(6*N^2) + sigma_doubly_asterisked)^0.5
d <-array(0, dim=c(2,2,7))
#1st parameter: 1 = d_1,                    2 = d_2
#2nd parameter: 1 = for Geo. Average Price, 2 = for Geo. Average Strike
#3rd parameter: For different N's
for (k in 1:7){
d[1, 1, k] <- (log(S_0/K) + (r-del_asterisked[k]+0.5*sigma_asterisked[k]^2)*T)/(sigma_asterisked[k]*T^0.5)
d[2, 1, k] <- d[1,1,k] - sigma_asterisked[k]*T^0.5
d[1, 2, k] <- (log(S_0/K) + (del_asterisked[k]-del+0.5*sigma_doubly_asterisked[k]^2)*T)/(sigma_doubly_asterisked[k]*T^0.5)
d[2, 2, k] <- d[1,1,k] - sigma_doubly_asterisked[k]*T^0.5
}
### Step 2.2 Compute the analytical Values ###
for(i in 3:9){
MatrixTable[3, i, 2] <- S_0*exp(-del_asterisked[i-2]*T)*pnorm(d[1, 1, i-2]) - K*exp(-r*T)*pnorm(d[2, 1, i-2])
MatrixTable[3, i, 3] <- K*exp(-r*T)*pnorm(-d[2, 1, i-2]) - S_0*exp(-del_asterisked[i-2]*T)*pnorm(-d[1, 1, i-2])
MatrixTable[3, i, 4] <- S_0*exp(-del*T)*pnorm(d[1, 2, i-2]) - K*exp(-del_asterisked[i-2]*T)*pnorm(d[2, 2, i-2])
MatrixTable[3, i, 5] <- K*exp(-del_asterisked[i-2]*T)*pnorm(-d[2, 2, i-2]) - S_0*exp(-del*T)*pnorm(-d[1, 2, i-2])
}
### Step 2.3 Print the result ###
MatrixTable[3,,] #Analytical values of geometric average
# Load all functions related to the experiement
source("functions_simulation_results.R")
#load simulation parameters
source("simulation_parameters.R")
# SELECT WITH AND WITHOUT JUMPS + SAMPLE SIZE
S$jump.v <- FALSE
S$jump.y <- FALSE
l.sample  <- 500
# get indices of paths with either a jump in V or Y
ijyv      <- unique(which(Z.y != 0 | Z.v != 0, arr.ind = TRUE)[,1])
# get indices of paths without any jumps
inoj      <- as.vector(1:S$n.traj.obs)[-ijyv]
# sample 500 paths with/without jumps
if(S$jump.v == FALSE | S$jump.y == FALSE){
i        <- sample(x = inoj,size = l.sample,replace = FALSE)
V        <- V[i,]
Y        <- Y[i,]
Z.y      <- Z.y[i,]
Z.v      <- Z.v[i,]
dI       <- dI[i,]
}else{
i        <- sample(x = ijyv,size = l.sample,replace = FALSE)
V        <- V[i,]
Y        <- Y[i,]
Z.y      <- Z.y[i,]
Z.v      <- Z.v[i,]
dI       <- dI[i,]
}
# Initializing vectors
X1          <- matrix(rnorm(n=S$n.traj.obs*S$n.step.obs*S$n.days, mean=0, sd=1),
nrow=S$n.traj.obs, ncol=S$n.step.obs*S$n.days)
X2          <- matrix(rnorm(n=S$n.traj.obs*S$n.step.obs*S$n.days, mean=0, sd=1),
nrow=S$n.traj.obs, ncol=S$n.step.obs*S$n.days)
V.start      <- rep(P$v0, S$n.traj.obs)
Y.start      <- rep(P$y0, S$n.traj.obs)
W.v          <- X1
Z.v          <- matrix(nrow=S$n.traj.obs, ncol=S$n.step.obs*S$n.days)
V_           <- matrix(nrow=S$n.traj.obs, ncol=S$n.step.obs*S$n.days+1)
V            <- matrix(nrow=S$n.traj.obs, ncol=S$n.step.obs*S$n.days+1)
V.close      <- matrix(nrow=S$n.traj.obs, ncol=S$n.days+1)
V_[,1]       <- V.start
V[,1]        <- V.start
V.close[,1]  <- V.start
sum.jump.v   <- matrix(ncol=S$n.days,nrow=S$n.traj.obs)
W.y          <- P$rho * X1 + sqrt(1-P$rho^2) * X2
Z.y          <- matrix(nrow=S$n.traj.obs, ncol=S$n.step.obs*S$n.days)
Y            <- matrix(nrow=S$n.traj.obs, ncol=S$n.step.obs*S$n.days+1)
Y_           <- matrix(nrow=S$n.traj.obs, ncol=S$n.step.obs*S$n.days+1)
Y.close      <- matrix(nrow=S$n.traj.obs, ncol=S$n.days+1)
Y.close[,1]  <- Y.start
Y[,1]        <- Y.start
Y_[,1]       <- Y.start
sum.jump.y   <- matrix(ncol=S$n.days,nrow=S$n.traj.obs)
dI           <- matrix(ncol=S$n.step.obs*S$n.days,nrow=S$n.traj.obs)
idx          <- matrix(ncol=S$n.days,nrow=S$n.traj.obs)
quad.var     <- matrix(ncol=S$n.days,nrow=S$n.traj.obs)
int.var      <- matrix(ncol=S$n.days,nrow=S$n.traj.obs)
day <- 1
source("functions_simulation_results.R")
#load simulation parameters
source("simulation_parameters.R")
source("model_parameters.R")
source("observation_simulation_euler_P.R")
#Library
library(vars)
library(ucminf)
library(rgenoud)
library(matlib)
install.packages("vars")
install.packages("ucminf")
install.packages("rgenoud")
install.packages("matlib")
CDNbonds <- read.table("bond yield partial.csv", header=TRUE, sep=",", na.strings=" ")
plot(CDNbonds$X2.year, type="l",xaxt='n', col="green", main="Bond Yields",ylab="annualized bond yields",lwd=1,xlab="time")
axis(side=1, at=seq(1, 306, by=60),labels=CDNbonds$Date[seq(1, 306, by=60)])
legend(x=10,y=0.09,legend=c("3 month","1 year", "2 year","5 year", "10 year", "15 year"), col=c("red", "green", "purple", "orange", "black"),lty=1,lwd=1, horiz = T)
lines(CDNbonds$X3.month, type="l",lwd=1,col="red")
lines(CDNbonds$X5.year, type="l",lwd=1,col="purple")
lines(CDNbonds$X10.year, type="l",lwd=1,col="orange")
lines(CDNbonds$X15.year, type = "l", lwd = 1, col = "black")
lines(CDNbonds$X1.year, type = "l", lwd = 1, col = "blue")
DIR
dir
setwd("~/GitHub/pension-lulu/Rcode")
CDNbonds <- read.table("bond yield partial.csv", header=TRUE, sep=",", na.strings=" ")
plot(CDNbonds$X2.year, type="l",xaxt='n', col="green", main="Bond Yields",ylab="annualized bond yields",lwd=1,xlab="time")
axis(side=1, at=seq(1, 306, by=60),labels=CDNbonds$Date[seq(1, 306, by=60)])
legend(x=10,y=0.09,legend=c("3 month","1 year", "2 year","5 year", "10 year", "15 year"), col=c("red", "green", "purple", "orange", "black"),lty=1,lwd=1, horiz = T)
lines(CDNbonds$X3.month, type="l",lwd=1,col="red")
lines(CDNbonds$X5.year, type="l",lwd=1,col="purple")
lines(CDNbonds$X10.year, type="l",lwd=1,col="orange")
lines(CDNbonds$X15.year, type = "l", lwd = 1, col = "black")
lines(CDNbonds$X1.year, type = "l", lwd = 1, col = "blue")
BondsMonthly = as.matrix(CDNbonds[c(2:10)])
BondsMonthly = BondsMonthly / 12
plot(BondsMonthly[, 2], type = "l", xaxt = 'n', col = "green", main = "Bond Yields", ylab = "Monthly Rate", lwd = 1.5, xlab = "Date")
axis(side = 1, at = seq(1, 306, by = 60), labels = CDNbonds$Date[seq(1, 306, by = 60)])
legend(x = 95, y = 0.0076,legend = c("3-month", "1-year", "2-year", "5-year", "10-year", "15-year"), col = c("red", "green", "purple", "orange", "black"), lty = 1, lwd = 1, horiz = T, cex =0.6)
ylim = -0.001:0.009
lines(BondsMonthly[, 3], type = "l", lwd = 1, col = "red")
lines(BondsMonthly[, 4], type = "l", lwd = 1, col = "purple")
lines(BondsMonthly[, 6], type = "l", lwd = 1, col = "orange")
lines(BondsMonthly[, 8], type = "l", lwd = 1, col = "black")
lines(BondsMonthly[, 9], type = "l", lwd = 1, col = "blue")
#inflation
CDNinflation <- read.table("canada cpi.csv", header=TRUE, sep=",", na.strings=" ")
CDNinfrate<-CDNinflation$continuous
plot(CDNinfrate, type="l", main = "Inflation Rate", xaxt='n', xlab="Date", ylab="Monthly Rate")
axis(side=1, at=seq(1, 306, by=60),labels=CDNbonds$Date[seq(1, 306, by=60)])
#Canadian stock TSX
TSXindex <- read.table("TSX with dividen.csv", header=TRUE, sep=",", na.strings=" ")
CDNstock <- TSXindex$conti
#CDNstock <- TSXindex$conti + CDNdividend
plot(12*CDNstock, type="l", main = "TSX stock return", xaxt='n', xlab="time",ylab="continuously compounded annual rate")
axis(side=1, at=seq(1, 306, by=60),labels=CDNbonds$Date[seq(1, 306, by=60)])
ExCDNstock <- CDNstock - BondsMonthly[,2]
plot(ExCDNstock, type="l", main = "Excess Stock Return", xaxt='n', xlab="Date",ylab="Monthly Rate")
axis(side=1, at=seq(1, 306, by=60),labels=CDNbonds$Date[seq(1, 306, by=60)])
#Canadian stock dividend yield
CDNdividend <-TSXindex$DividenMonth
plot(CDNdividend, type="l", main = "Dividend Yield", xaxt='n', xlab="Date",ylab="Monthly Rate")
axis(side = 1, at = seq(1, 306, by = 60), labels = CDNbonds$Date[seq(1, 306, by = 60)])
#make z4 as stock return + dividend yield - bondsMonthly
ExCDNstock <- ExCDNstock + CDNdividend
VARinput <- data.frame(tbill = BondsMonthly[, 2], bonds15 = BondsMonthly[, 9], infrate = CDNinfrate, TSXexcess = ExCDNstock)
MeanData <- apply(X = VARinput, MARGIN = 2, FUN = mean)
StdData <- apply(X = VARinput, MARGIN = 2, FUN = sd)
##Combine the input of VAR data into one data frame
VARinput <- data.frame(tbill = BondsMonthly[,2], bonds15 = BondsMonthly[,9], infrate = CDNinfrate, TSXexcess = ExCDNstock)
MeanData <- apply(X=VARinput, MARGIN=2, FUN=mean)
StdData  <- apply(X=VARinput, MARGIN=2, FUN=sd)
##Center the data at mean=0
ZeroMeanData <- VARinput
ZeroMeanData$tbill <- VARinput$tbill-MeanData[1]
ZeroMeanData$bonds15 <- VARinput$bonds15-MeanData[2]
ZeroMeanData$infrate <- VARinput$infrate-MeanData[3]
ZeroMeanData$TSXexcess <- VARinput$TSXexcess - MeanData[4]
##Estimate the VAR(1) model
VAR1model <- VAR(ZeroMeanData,p = 1, type="none")
VAR1result<- summary(VAR1model)
#Library
library(vars)
library(ucminf)
library(rgenoud)
library(matlib)
##library(MTS)
##Estimate the VAR(1) model
VAR1model <- VAR(ZeroMeanData,p = 1, type="none")
VAR1result<- summary(VAR1model)
B=Bcoef(VAR1model)
Nu=(diag(4)-B)%*%MeanData
Sigma = VAR1result$covres
B
Mu
Nu
Sigma
CDSigma = chol(Sigma)
abseigen=abs(eigen(B)$value)
abseigen
c
c(1:9)
View(BondsMonthly)
View(BondsMonthly)
CDNbonds_full <- read.table("bond yield monthly full.csv", header=TRUE, sep=",", na.strings=" ")
View(CDNbonds_full)
View(CDNbonds_full)
View(CDNbonds_full)
View(CDNbonds_full)
CDNbonds_full=CDNbonds_full[,2:9]
View(CDNbonds_full)
View(CDNbonds_full)
View(BondsMonthly)
View(BondsMonthly)
View(CDNbonds_full)
View(CDNbonds_full)
CDNbonds_full=CDNbonds_full/12
View(CDNbonds_full)
View(CDNbonds_full)
rankedCDNbonds=CDNbonds_full[,c(1:8)]
histdata=as.matrix(rankedCDNbonds)
VARaffine = as.matrix(VARinput)
Nhist=nrow(histdata)
Nhist
delta0=0
delta1=c(1,0,0,0)
181/12
histdata
#Estimating the parameter by minimize the value of sum of squares
Optimizefunc = function(sl){
sl1matrix=matrix(data = c(sl[1:4],sl[5:8],0,0,0,0,B[4,]),4,4,byrow=TRUE)
sl0vector=c(sl[9],sl[10],0,Nu[4])
AnVector=numeric(181)
BnMatrix=matrix(data=0,nrow=4,ncol=181)
for(i in 2:181){
BnMatrix[,i] = -delta1+t(B-sl1matrix)%*%BnMatrix[,i-1]
AnVector[i]  = -delta0+AnVector[i-1]+t(BnMatrix[,i-1])%*%(Nu-sl0vector)+0.5*t(BnMatrix[,i-1])%*%t(CDSigma)%*%CDSigma%*%BnMatrix[,i-1]
}
yfit=matrix(data=0,nrow=Nhist,ncol=7)
for (i in 1:Nhist){
yfit[i, 1] = -1 / 12 * (AnVector[13] - sum(BnMatrix[, 13] * (VARaffine[i,])))
yfit[i, 2] = -1 / 36 * (AnVector[37] + sum(BnMatrix[, 37] * (VARaffine[i,])))
yfit[i, 3] = -1 / 60 * (AnVector[61] + sum(BnMatrix[, 61] * (VARaffine[i,])))
yfit[i, 4] = -1 / 84 * (AnVector[85] + sum(BnMatrix[, 85] * (VARaffine[i,])))
yfit[i, 5] = -1 / 120 * (AnVector[121] + sum(BnMatrix[, 121] * (VARaffine[i,])))
yfit[i, 6] = -1 / 144 * (AnVector[145] + sum(BnMatrix[, 145] * (VARaffine[i,])))
yfit[i, 7] = -1 / 168 * (AnVector[169] + sum(BnMatrix[, 169] * (VARaffine[i,])))
yfit[i, 8] = -1 / 180 * (AnVector[181] + sum(BnMatrix[, 181] * (VARaffine[i,])))
}
sumsquared = sum((yfit-histdata)^2)
return(sumsquared)
}
Optimizefunc([0,0,0,0,0,0,0,0,0,0])
Optimizefunc(c(0,0,0,0,0,0,0,0,0,0))
BnMatrix
B
sl1matrix=matrix(data = c(sl[1:4],sl[5:8],0,0,0,0,B[4,]),4,4,byrow=TRUE)
sl = c(0,0,0,0,0,0,0,0,0,0)
sl1matrix=matrix(data = c(sl[1:4],sl[5:8],0,0,0,0,B[4,]),4,4,byrow=TRUE)
sl0vector=c(sl[9],sl[10],0,Nu[4])
AnVector=numeric(181)
BnMatrix=matrix(data=0,nrow=4,ncol=181)
for(i in 2:181){
BnMatrix[,i] = -delta1+t(B-sl1matrix)%*%BnMatrix[,i-1]
AnVector[i]  = -delta0+AnVector[i-1]+t(BnMatrix[,i-1])%*%(Nu-sl0vector)+0.5*t(BnMatrix[,i-1])%*%t(CDSigma)%*%CDSigma%*%BnMatrix[,i-1]
}
BnMatrix
yfit=matrix(data=0,nrow=Nhist,ncol=7)
for (i in 1:Nhist){
yfit[i, 1] = -1 / 12 * (AnVector[13] - sum(BnMatrix[, 13] * (VARaffine[i,])))
yfit[i, 2] = -1 / 36 * (AnVector[37] + sum(BnMatrix[, 37] * (VARaffine[i,])))
yfit[i, 3] = -1 / 60 * (AnVector[61] + sum(BnMatrix[, 61] * (VARaffine[i,])))
yfit[i, 4] = -1 / 84 * (AnVector[85] + sum(BnMatrix[, 85] * (VARaffine[i,])))
yfit[i, 5] = -1 / 120 * (AnVector[121] + sum(BnMatrix[, 121] * (VARaffine[i,])))
yfit[i, 6] = -1 / 144 * (AnVector[145] + sum(BnMatrix[, 145] * (VARaffine[i,])))
yfit[i, 7] = -1 / 168 * (AnVector[169] + sum(BnMatrix[, 169] * (VARaffine[i,])))
yfit[i, 8] = -1 / 180 * (AnVector[181] + sum(BnMatrix[, 181] * (VARaffine[i,])))
}
yfit=matrix(data=0,nrow=Nhist,ncol=8)
for (i in 1:Nhist){
yfit[i, 1] = -1 / 12 * (AnVector[13] - sum(BnMatrix[, 13] * (VARaffine[i,])))
yfit[i, 2] = -1 / 36 * (AnVector[37] + sum(BnMatrix[, 37] * (VARaffine[i,])))
yfit[i, 3] = -1 / 60 * (AnVector[61] + sum(BnMatrix[, 61] * (VARaffine[i,])))
yfit[i, 4] = -1 / 84 * (AnVector[85] + sum(BnMatrix[, 85] * (VARaffine[i,])))
yfit[i, 5] = -1 / 120 * (AnVector[121] + sum(BnMatrix[, 121] * (VARaffine[i,])))
yfit[i, 6] = -1 / 144 * (AnVector[145] + sum(BnMatrix[, 145] * (VARaffine[i,])))
yfit[i, 7] = -1 / 168 * (AnVector[169] + sum(BnMatrix[, 169] * (VARaffine[i,])))
yfit[i, 8] = -1 / 180 * (AnVector[181] + sum(BnMatrix[, 181] * (VARaffine[i,])))
}
sumsquared = sum((yfit-histdata)^2)
sumsquared
#Estimating the parameter by minimize the value of sum of squares
Optimizefunc = function(sl){
sl1matrix=matrix(data = c(sl[1:4],sl[5:8],0,0,0,0,B[4,]),4,4,byrow=TRUE)
sl0vector=c(sl[9],sl[10],0,Nu[4])
AnVector=numeric(181)
BnMatrix=matrix(data=0,nrow=4,ncol=181)
for(i in 2:181){
BnMatrix[,i] = -delta1+t(B-sl1matrix)%*%BnMatrix[,i-1]
AnVector[i]  = -delta0+AnVector[i-1]+t(BnMatrix[,i-1])%*%(Nu-sl0vector)+0.5*t(BnMatrix[,i-1])%*%t(CDSigma)%*%CDSigma%*%BnMatrix[,i-1]
}
yfit=matrix(data=0,nrow=Nhist,ncol=8)
for (i in 1:Nhist){
yfit[i, 1] = -1 / 12 * (AnVector[13] - sum(BnMatrix[, 13] * (VARaffine[i,])))
yfit[i, 2] = -1 / 36 * (AnVector[37] + sum(BnMatrix[, 37] * (VARaffine[i,])))
yfit[i, 3] = -1 / 60 * (AnVector[61] + sum(BnMatrix[, 61] * (VARaffine[i,])))
yfit[i, 4] = -1 / 84 * (AnVector[85] + sum(BnMatrix[, 85] * (VARaffine[i,])))
yfit[i, 5] = -1 / 120 * (AnVector[121] + sum(BnMatrix[, 121] * (VARaffine[i,])))
yfit[i, 6] = -1 / 144 * (AnVector[145] + sum(BnMatrix[, 145] * (VARaffine[i,])))
yfit[i, 7] = -1 / 168 * (AnVector[169] + sum(BnMatrix[, 169] * (VARaffine[i,])))
yfit[i, 8] = -1 / 180 * (AnVector[181] + sum(BnMatrix[, 181] * (VARaffine[i,])))
}
sumsquared = sum((yfit-histdata)^2)
return(sumsquared)
}
slbest=vector("double",10)
minfunc=100
for(i in 1:1){
sl<-ucminf(par=runif(10,min=-0.0000,max=0.0000),fn=Optimizefunc,control = list(xtol = 1e-30))$par
vfunc<-Optimizefunc(sl)
if(vfunc<minfunc){
slbest=sl
minfunc=vfunc
}
}
slbest
minfunc
B
SIgma
Sigma
CDSigma
slbest
L1 = matrix(data=c(slbest[1:4],slbest[5:8],0,0,0,0,B[4,]),4,4,byrow=TRUE)
L1
L0 = c(slbest[9],slbest[10],0,Nu[4])
L0
slbest
CDSigma
solve(CDSigma)
solve(t(CDSigma))
solve(t(CDSigma))%*%L1
(t(CDSigma))%*%L1
slbest
